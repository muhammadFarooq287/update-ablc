import ie from"pino";import{RELAYER_DEFAULT_PROTOCOL as ne,RELAYER_EVENTS as re,EXPIRER_EVENTS as oe,Store as $,Core as ae}from"@walletconnect/core";import{getDefaultLoggerOptions as ce,generateChildLogger as le,getLoggerContext as pe}from"@walletconnect/logger";import{IEngine as he,ISignClient as de}from"@walletconnect/types";import{TYPE_1 as ge,createDelayedPromise as q,engineEvent as p,getInternalError as c,calcExpiry as I,isValidObject as k,getRequiredNamespacesFromNamespaces as we,getSdkError as _,isSessionCompatible as me,isExpired as f,isValidParams as m,isUndefined as X,isValidRequiredNamespaces as ue,isValidRelays as ye,isValidNamespaces as M,isConformingNamespaces as J,isValidString as D,isValidErrorReason as Se,isValidRelay as Ee,isValidController as Ie,isValidNamespacesChainId as H,isValidRequest as _e,isValidNamespacesRequest as Re,isValidRequestExpiry as Ne,isValidResponse as qe,isValidEvent as fe,isValidNamespacesEvent as ve,parseExpirerTarget as Pe,isValidId as Ve,getAppMetadata as Oe}from"@walletconnect/utils";import Te,{EventEmitter as xe}from"events";import{THIRTY_DAYS as De,SEVEN_DAYS as F,FIVE_MINUTES as u,ONE_DAY as v,THIRTY_SECONDS as Q}from"@walletconnect/time";import{isJsonRpcResult as R,isJsonRpcError as N,formatJsonRpcRequest as Ae,formatJsonRpcResult as Ce,formatJsonRpcError as Le,isJsonRpcRequest as be,isJsonRpcResponse as Ge}from"@walletconnect/jsonrpc-utils";const U="wc",K=2,z="client",A=`${U}@${K}:${z}:`,C={name:z,logger:"error",controller:!1,relayUrl:"wss://relay.walletconnect.com"},$e={session_proposal:"session_proposal",session_update:"session_update",session_extend:"session_extend",session_ping:"session_ping",session_delete:"session_delete",session_expire:"session_expire",session_request:"session_request",session_event:"session_event",proposal_expire:"proposal_expire"},Me={database:":memory:"},Ue={created:"history_created",updated:"history_updated",deleted:"history_deleted",sync:"history_sync"},Ke="history",ze="0.3",B="proposal",je=De,Z="session",T=F,W="engine",P={wc_sessionPropose:{req:{ttl:u,prompt:!0,tag:1100},res:{ttl:u,prompt:!1,tag:1101}},wc_sessionSettle:{req:{ttl:u,prompt:!1,tag:1102},res:{ttl:u,prompt:!1,tag:1103}},wc_sessionUpdate:{req:{ttl:v,prompt:!1,tag:1104},res:{ttl:v,prompt:!1,tag:1105}},wc_sessionExtend:{req:{ttl:v,prompt:!1,tag:1106},res:{ttl:v,prompt:!1,tag:1107}},wc_sessionRequest:{req:{ttl:u,prompt:!0,tag:1108},res:{ttl:u,prompt:!1,tag:1109}},wc_sessionEvent:{req:{ttl:u,prompt:!0,tag:1110},res:{ttl:u,prompt:!1,tag:1111}},wc_sessionDelete:{req:{ttl:v,prompt:!1,tag:1112},res:{ttl:v,prompt:!1,tag:1113}},wc_sessionPing:{req:{ttl:Q,prompt:!1,tag:1114},res:{ttl:Q,prompt:!1,tag:1115}}},L={min:u,max:F},ee="request";var Ye=Object.defineProperty,ke=Object.defineProperties,Xe=Object.getOwnPropertyDescriptors,se=Object.getOwnPropertySymbols,Je=Object.prototype.hasOwnProperty,He=Object.prototype.propertyIsEnumerable,te=(h,n,e)=>n in h?Ye(h,n,{enumerable:!0,configurable:!0,writable:!0,value:e}):h[n]=e,y=(h,n)=>{for(var e in n||(n={}))Je.call(n,e)&&te(h,e,n[e]);if(se)for(var e of se(n))He.call(n,e)&&te(h,e,n[e]);return h},j=(h,n)=>ke(h,Xe(n));class Fe extends he{constructor(n){super(n),this.name=W,this.events=new Te,this.initialized=!1,this.ignoredPayloadTypes=[ge],this.init=async()=>{this.initialized||(await this.cleanup(),this.registerRelayerEvents(),this.registerExpirerEvents(),this.client.core.pairing.register({methods:Object.keys(P)}),this.initialized=!0)},this.connect=async e=>{this.isInitialized(),await this.isValidConnect(e);const{pairingTopic:s,requiredNamespaces:t,relays:i}=e;let r=s,o,a=!1;if(r&&(a=this.client.core.pairing.pairings.get(r).active),!r||!a){const{topic:E,uri:g}=await this.client.core.pairing.create();r=E,o=g}const l=await this.client.core.crypto.generateKeyPair(),d={requiredNamespaces:t,relays:i??[{protocol:ne}],proposer:{publicKey:l,metadata:this.client.metadata}},{reject:S,resolve:w,done:V}=q();if(this.events.once(p("session_connect"),async({error:E,session:g})=>{if(E)S(E);else if(g){g.self.publicKey=l;const O=j(y({},g),{requiredNamespaces:g.requiredNamespaces});await this.client.session.set(g.topic,O),await this.setExpiry(g.topic,g.expiry),r&&await this.client.core.pairing.updateMetadata({topic:r,metadata:g.peer.metadata}),w(O)}}),!r){const{message:E}=c("NO_MATCHING_KEY",`connect() pairing topic: ${r}`);throw new Error(E)}const x=await this.sendRequest(r,"wc_sessionPropose",d),G=I(u);return await this.setProposal(x,y({id:x,expiry:G},d)),{uri:o,approval:V}},this.pair=async e=>(this.isInitialized(),await this.client.core.pairing.pair(e)),this.approve=async e=>{this.isInitialized(),await this.isValidApprove(e);const{id:s,relayProtocol:t,namespaces:i}=e,r=this.client.proposal.get(s);let{pairingTopic:o,proposer:a,requiredNamespaces:l}=r;k(l)||(l=we(i,"approve()"),this.client.proposal.set(s,j(y({},r),{requiredNamespaces:l})));const d=await this.client.core.crypto.generateKeyPair(),S=a.publicKey,w=await this.client.core.crypto.generateSharedKey(d,S),V={relay:{protocol:t??"irn"},namespaces:i,requiredNamespaces:l,controller:{publicKey:d,metadata:this.client.metadata},expiry:I(T)};await this.client.core.relayer.subscribe(w);const x=await this.sendRequest(w,"wc_sessionSettle",V),{done:G,resolve:E,reject:g}=q();this.events.once(p("session_approve",x),({error:Y})=>{Y?g(Y):E(this.client.session.get(w))});const O=j(y({},V),{topic:w,acknowledged:!1,self:V.controller,peer:{publicKey:a.publicKey,metadata:a.metadata},controller:d});return await this.client.session.set(w,O),await this.setExpiry(w,I(T)),o&&await this.client.core.pairing.updateMetadata({topic:o,metadata:O.peer.metadata}),o&&s&&(await this.sendResult(s,o,{relay:{protocol:t??"irn"},responderPublicKey:d}),await this.client.proposal.delete(s,_("USER_DISCONNECTED")),await this.client.core.pairing.activate({topic:o})),{topic:w,acknowledged:G}},this.reject=async e=>{this.isInitialized(),await this.isValidReject(e);const{id:s,reason:t}=e,{pairingTopic:i